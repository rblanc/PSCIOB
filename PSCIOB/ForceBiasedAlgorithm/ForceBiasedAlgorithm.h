/* * This file is part of the psciob library. * * Copyright (c) 2012, Remi Blanc, University of Bordeaux * All rights reserved. *  * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions are met:  *  * 1. Redistributions of source code must retain the above copyright notice, this *    list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright notice, *    this list of conditions and the following disclaimer in the documentation *    and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. *//*** \file ForceBiasedAlgorithm.h* \author Rémi Blanc * \date 31. July 2012*/#ifndef __FORCEBIASEDALGORITHM_H_#define __FORCEBIASEDALGORITHM_H_#include "BaseScene.h"#include "FBMovementManager.h"namespace psciob {/** \brief ForceBiasedAlgorithm** This is the base class for implementing the force-biased algorithm.* This algorithm is a deterministic, collective re-arrangement method for removing overlaps between geometric objects* From an initial collection, for each pair of intersecting objects, it proposes a displacment aiming at reducing the overlaps* All proposal moves are composed, and applied simultaneously. The objects are slightly downscaled, and the process is iterated until* no intersection remain.** The algorithm works with a FBMovementManager to deal with different kinds of moves (translations, possibly rotations, scaling) for the various object types...* The default FBMovementManager performs only translations** This algorithm requires the scene to work with a interaction manager that deals with overlaps only.*///IDEA: use a temporary scene ?? in which to perform all computations...?//DEV: implement a structure, with one entry per object, in which to store the proposal moves, and perform the necessary compositions.//how to store those moves??? -> matrices seem to be the most generic way.//I could just store the parameter modifications to be applied here, and let the manager deal with this...template<class TScene>class ForceBiasedAlgorithm : public itk::LightObject {public:	/** Standard class typedefs. */	typedef ForceBiasedAlgorithm    Self;	typedef itk::LightObject        Superclass;	typedef itk::SmartPointer<Self> Pointer;	/** Run-time type information (and related methods). */	itkTypeMacro(ForceBiasedAlgorithm, itk::LightObject);	itkNewMacro(Self);	typedef TScene                                     SceneType;	typedef typename SceneType::IDType                 IDType;	typedef typename SceneType::ObjectTypesLibraryType ObjectTypesLibraryType;	typedef typename SceneType::DeformableObjectType   ObjectType;	/** Attach a scene to the algorithm */	void SetScene(SceneType* scene) { 		m_scene = scene;		m_mvtManager->SetScene(m_scene);	}	/** Set a specific movement manager, this object is in charge of proposing and applying moves to the objects of the scene */	void SetMovementManager(FBMovementManager* mm) { 		m_mvtManager = mm;		if (!m_scene) {} else { m_mvtManager->SetScene(m_scene); }	}		/** Get a pointer to the movement manager 	* this is useful, in particular for (re)defining specific aspects of the manager	*/	void GetMovementManager() { return m_mvtManager; }	/** Set the maximum number of iterations for the method IterateUntilConvergence - default is 1e10 */	void SetMaximumNumberOfIterations(unsigned n) {m_maxNbIteration=n;}	/** Get the maximum number of iterations for the method IterateUntilConvergence - default is 1e10 */	unsigned GetMaximumNumberOfIterations() { return m_maxNbIteration;}		/** Set the scaling coefficient, to be applied at the end of each iteration 	* Values should be in ]0,1] ; if the input is outside this range, value 1 is set instead	* If the value is 1 (default behavior), no scaling is applied	* Otherwise, it should be specified, for each object type, which is the coefficient that performs scaling... this is done through the object movement manager...	*/	void SetScalingAmount(double s) {		if (s<=0) {m_scaleFactor=1;return;}		if (s>=1) {m_scaleFactor=1;return;}		m_scaleFactor = s;	}		/** Get the value of the scaling parameter */	double GetScalingAmount() {return m_scaleFactor;}	/** Applies a single iteration of the algorithm 	* returns false if no overlaps were present anyway.	*/	bool ApplyOneIteration() {		m_proposedMoves.clear(); //make sure it starts empty.		//initialize the moves to identity for all objects (m_proposedMoves)				//check for overlaps between objects -> turn on the TurnOnInteractionManagement for the interactionManager of the scene		//for each pair of overlapping objects, propose a move, and compose it with the existing m_proposedMoves						//apply scaling.					//apply the moves		// TurnOffInteractionManagement for the interactionManager of the scene		//	apply the moves		// TurnOnInteractionManagement				//if nothing happen, return false 	}		/** Iterate until convergence 	* returns -1 if it exited after reaching the maximum number of allowed iterations	* and 1 otherwise.	*/	int IterateUntilConvergence() {		if (!m_scene) throw DeformableModelException("ForceBiasedAlgorithm::IterateUntilConvergence -- the scene must be set first.");		unsigned nbIter=0;		int converged = 0;		while (converged==0) {			nbIter++;			if (nbIter>=m_maxNbIteration) { converged = -1; break; }						if (!this->ApplyOneIteration()) converged = 1;					}		return converged;	}protected:	ForceBiasedAlgorithm() : {		m_scene = 0;		m_maxNbIteration = 1e10;		m_mvtManager = FBMovementManager::New();	};	~ForceBiasedAlgorithm() {};	typename SceneType::Pointer m_scene;	unsigned m_maxNbIteration;	FBMovementManager::Pointer m_mvtManager;		//temporary storage for the proposal movements	//it associate a vnl_vector representing the parameters of the proposed moves.	//those are initialized, filled, and composed using the FBMovementManager	std::map<IDType, vnl_vector<double>> m_proposedMoves;private:	ForceBiasedAlgorithm(const Self&);      //purposely not implemented	const Self & operator=( const Self & ); //purposely not implemented};} // namespace psciob#endif /* __FORCEBIASEDALGORITHM_H_ */